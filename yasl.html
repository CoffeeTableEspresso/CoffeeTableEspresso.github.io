<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="my website">
<base href="/">
<title>YASL - Documentation</title>
<link rel="stylesheet" href="assets/css/style.css">
</head>
<body>
  
  <!-- Header -->
    <!-- include includes/header.html here -->
  <header>
    <div>
      <a href="index.html">home</a>
    </div>
  </header>
  
  <div>
    <h1> YASL Reference Manual </h1>
    <p> The reference manual for the YASL programming language. </p>
    <b> LAST UPDATED 05/06/2018 </b>
    <h2> Contents </h2>
    <ul>
      <li> <a href="yasl.html#1">1 &ndash; Introduction </a> </li>
      <p></p>
      <li> <a href="yasl.html#2">2 &ndash; Basic Concepts </a> </li>
      <ul>
        <li> <a href="yasl.html#2.1">2.1 &ndash; Values &amp; Types </a> </li>
      </ul>
      <p></p>
      <li> <a href="yasl.html#3">3 &ndash; The Language </a> </li>
      <ul>
        <li> <a href="yasl.html#3.1">3.1 &ndash; Lexical Conventions </a> </li>
        <li> <a href="yasl.html#3.2">3.2 &ndash; Variables </a> </li>
        <li> <a href="yasl.html#3.3">3.3 &ndash; Statements </a> </li>
        <ul>
          <li> <a href="yasl.html#3.3.1">3.3.1 &ndash; Function Declarations </a> </li>
        </ul>
        <li> <a href="yasl.html#3.4">3.4 &ndash; Expressions </a> </li>
        <ul>
          <li> <a href="yasl.html#3.4.1">3.4.1 &ndash; Arithmetic Operators </a> </li>
          <li> <a href="yasl.html#3.4.2">3.4.2 &ndash; Bitwise Operators </a>
          <li> <a href="yasl.html#3.4.3">3.4.3 &ndash; Logical Operators </a> </li>
          <li> <a href="yasl.html#3.4.4">3.4.4 &ndash; Comparison Operators </a> </li>
          <li> <a href="yasl.html#3.4.5">3.4.5 &ndash; Other Operators </a> </li>
          <li> <a href="yasl.html#3.4.6">3.4.6 &ndash; Precedence </a> </li>
          <li> <a href="yasl.html#3.4.7">3.4.7 &ndash; Function Calls </a> </li>
          <li> <a href="yasl.html#3.4.8">3.4.8 &ndash; Method Calls </a> </li>
        </ul>
      </ul>
      <li> <a href="yasl.html#4">4 &ndash; The Standard Library </a> </li>
    </ul>
  
  <div>
    <h2> <a name="1">1 &ndash; Introduction </a> </h2>
    <p> YASL is a small scripting langugage. </p>
    <h2> <a name="2">2 &ndash; Basic Concepts </a> </h2>
    <p> This section describes the basic concepts of the language. </p>
    <h3> <a name="2.1">2.1 &ndash; Values &amp; Types </a> </h3>
    <p> YASL is <em>dynamically typed</em>. There are no type definitions. All values carry their own type. </p>
    <p> The basic types in YASL are: <em>undef</em>, <em>bool</em>, <em>int64</em>, and <em>float64</em>, <em>str</em>, 
      <em>list</em>, and <em>map</em>. The type <em>undef</em> has a single value, <b>undef</b>, which is mainly useful
      because it is different from all other values. The type <em>bool</em> has two values, <b>true</b> and <b>false</b>.
      <em>int64</em> represents integers with 64-bits of precision. <em>float64</em> represents IEEE floating-point values with 
      64-bits of precision. <em>str</em> are ascii strings. currently there is no support for unicode strings. <em>list</em>
      is a resizing array. <em>map</em> is a dictionary of key-value pairs, where a value can be looked up quickly given a 
      key.
    </p>
    <h2> <a name="3">3 &ndash; The Language </a> </h2>
    <p> This section describes the lexis, syntax, and semantics of YASL. Language constructs will be explained using the
      usual EBNF notation.
    </p>
    <h3> <a name="3.1">3.1 &ndash; Lexical Conventions </a> </h3>
    <p> Names in YASL consist of a  numbers, letters, and underscores, and may not start with a number. </p>
    <p> the following <em>keywords</em> are reserved and cannot be used as names: </p>
    <pre>
     and      bool    break     continue  else    elseif  enum   
     false    file    float64   fn        for     if      int64     
     let      list    map       or        print   return  str        
     struct   true    undef     while   
    </pre>
    <p> Of these, <em>bool</em>, <em>enum</em>, <em>file</em>, <em>float64</em>, <em>int64</em>, <em>list</em>, <em>map</em>, 
      <em>str</em>, and <em>struct</em> are currently unused, but reserved for future use. 
    </p>
    <h3> <a name="3.2">3.2 &ndash; Variables </a> </h3>
    <p> Variables store values. There are two kinds of varialbes in YASL: local and global. </p>
    <p> All variables are global unless not declared in the global scope, in which case the variable is local. Variables
      are declared with <code>decl_stmt ::= "let" NAME ["=" expr]</code>.</p>
    <h3> <a name="3.3">3.3 &ndash; Statements </a> </h3>
    <p> YASL has <em>if-</em> and <em>while-</em> statements with the following syntax:
      <code>while_loop ::= "while" expr "{" {stmt} "}"</code>
      <code>if_stmt ::= "if" expr "{" stmt* "}" ("elseif" expr "{" stmt* "}")* ["else" "{" stmt* "}"]</code>.
    </p>
    <p> <b>false</b>, <b>undef</b>, and <b>""</b> (empty string) are considered falsey, and all other values are truthy. 
      In particular, <b>0</b> and <b>0.0</b> are truthy. 
    </p>
    <h4> <a name="3.3.1">3.3.1 &ndash; Function Declarations </a> </h4>
    <p> functions can be declared with the following syntax: 
      <code>fn_decl ::= "fn" ID ":" ID ("," ID)* "->" "{" stmt* "}"</code>. Functions calls are expressions, and implicitly
      return <b>undef</b> if the function reaches the end of it's body with an explicit return.
    </p>
    <h3> <a name="3.4">3.4 &ndash; Expressions </a> </h3>
    <h4> <a name="3.4.1">3.4.1 &ndash; Arithmetic Operators </a> </h4>
    <p> YASL supports the following arithmetic operators: </p>
      <ul>
        <li><b>+</b>: addition</li>
        <li><b>-</b>: subtraction</li>
        <li><b>*</b>: multiplication</li>
        <li><b>/</b>: float division</li>
        <li><b>//</b>: integer division</li>
        <li><b>%</b>: modulo</li>
        <li><b>**</b>: exponentiation</li>
        <li><b>-</b>: unary minus</li>
      </ul>
    <p> Float division always returns a float. Integer division and modulo are only defined for integers, and always return 
      an integer.
    </p>
    <p> All other binary arithmetic operator work as 
      follows: If both operands are integers, the result is an integer. Otherwise, the operands are converted to floats 
      and the result is a float.
    </p>
    <h4> <a name="3.4.2">3.4.2 &ndash; Bitwise Operators </a> </h4>
    <p> YASL supports the following bitwise operators: </p>
      <ul>
        <li><b>|</b>: bitwise or</li>
        <li><b>&</b>: bitwise and</li>
        <li><b>^</b>: bitwise xor</li>
        <li><b>^</b>: bitwise negation</li>
      </ul>
    <p> All bitwise operators are only defined for integer operands. </p>
    <p> <b>^</b> is bitwise xor if used as a binary operator, and bitwise negation if used as a unary operator. </p>
    <h4> <a name="3.4.3">3.4.3 &ndash; Logical Operators </a> </h4>
    <p> The logical operators in YASL are <b>!</b>, <b>and</b>, and <b>or</b>.  Like the control structures, the logical 
      operators consider <b>false</b>, <b>undef</b>, and <b>""</b> as falsey, and anything else as truthy.
    </p>
    <p> <b>!</b> always returns a boolean. <b>and</b> returns its first argument if that argument is falsey, otherwise it 
      returns its second argument. <b>or</b> returns its first argument if that argument is truthy, otherwise it returns its 
      second argument.
    </p>
    <h4> <a name ="3.4.4">3.4.4 &ndash; Comparison Operators </a> </h4>
    <p> YASL supports the following comparison operators: </p>
      <ul>
        <li><b>===</b>: identity </li>
        <li><b>!==</b>: non-identity </li>
        <li><b>==</b>: equality </li>
        <li><b>!=</b>: inequality </li>
        <li><b>&gt;</b>: greater-than</li>
        <li><b>&lt;</b>: less-than</li>
        <li><b>&gt;=</b>: greater-than or equal</li>
        <li><b>&lt;=</b>: less-than or equal</li>
      </ul>
    <p> Comparisons between numeric types will behave as expected, and <em>int64</em> can be compared with 
      <em>float64</em>.
    </p>
    <p> <code>===</code> and <code>!==</code> are stricter versions of <code>==</code> and <code>!=</code>, comparing
      type, value, and identity (if applicable). 
    </p>
    <p> comparing anything with <b>undef</b> (including <b>undef</b> with itself) returns <b>undef</b>. </p>
    <h4> <a name="3.4.5">3.4.5 &ndash; Other Operators </a> </h4>
    <p> The <b>#</b> operator returns the size of its argument.  For strings, this is its length, and for maps and lists, this
      is the number of elements they contain.  Using <b>#</b> on values of any other type is a type error.
    </p>
    <p> YASL supports the ternary operator, with the usual notation.  YASL also supports a nil-coalescing operator
      (<b>??</b>), which returns its left operand if the left operand is not <b>undef</b>, and returns its right operand 
      otherwise.
    </p>
    <p> Both these operators are right associative. </p>
    <p> YASL also supports concatenation with the <b>||</b> and <b>|||</b> operators. The difference between the two is that
      <b>|||</b> will always attempt to coerce both its arguments to strings before concatenating them, and it will place a space
      between the two strings when it concatenates them. This is useful for concatenating a list and a str, for example. Using
      <b>||</b> on a list and a string is a type error.
    </p>
    <p> Both concatenation operators are right associative. </p>
    <h4> <a name="3.4.6">3.4.6 &ndash; Precedence </a> </h4>
    <p> The following table shows the precedence of YASL operators, from highest to lowest: </p>
    <table>
      <tr>
        <th> Precedence </th>
        <th> Operators </th>
        <th> Description </th>
        <th> Associativity </th>
        <!-- <th> Overloadable </th> -->
      </tr>
      <tr>
        <td> 1 </td>
        <td> ()<br/>[]<br/>. </td>
        <td> Function Calls<br/>Indexing<br/>Member Access</td>
        <td> Left </td>
        <!-- <td> No<br/>__set/__get<br/>No</td> -->
      </tr>
      <tr>
        <td> 2 </td>
        <td> ** </td>
        <td> Exponentiation </td>
        <td> Right </td>
        <!-- <td> __pow </td> -->
      </tr>
      <tr>
        <td> 3 </td>
        <td> +<br/>-<br/>#<br/>!<br/>^ </td>
        <td> Unary Plus<br/>Unary Minus<br/>Length<br/>Logical Negation<br/>Bitwise Negation</td>
        <td> Right </td>
        <!-- <td> __pos<br/>__neg<br/>__len<br/>__not<br/>__bnot </td> -->
      </tr>
      <tr>
        <td> 4 </td>
        <td> *<br/>/<br/>//<br/>%<br/> </td>
        <td>  Multiplication<br/>Float Division<br/>Integer Division<br/>Remainder</td>
        <td> Left </td>
        <!-- <td> __mul<br/>__fdiv<br/>__idiv<br/>__mod </td> -->
      </tr>
      <tr>
        <td> 5 </td>
        <td> +<br/>- </td>
        <td> Addition<br/>Subtraction </td>
        <td> Left </td>
        <!-- <td> __add<br/>__sub </td> -->
      </tr>
      <tr>
        <td> 6 </td>
        <td> &lt;&lt;<br/>&gt;&gt; </td>
        <td> Left Logical Shift<br/>Right Logical Shift</td>
        <td> Left </td>
        <!-- <td> __lshift<br/>__rshift </td> -->
      </tr>
            <tr>
        <td> 7 </td>
        <td> &amp;</td>
        <td> Bitwise And </td>
        <td> Left </td>
        <!-- <td> __band </td> -->
      </tr>
      <tr>
        <td> 8 </td>
        <td> ^ </td>
        <td> Bitwise Xor </td>
        <td> Left </td>
        <!-- <td> __bxor </td> -->
      </tr>
      <tr>
        <td> 9 </td>
        <td> | </td>
        <td> Bitwise Or </td>
        <td> Left </td>
        <!-- <td> __bor </td> -->
      </tr>
      <tr>
        <td> 10 </td>
        <td> ~ </td>
        <td> Concatenation </td>
        <td> Right </td>
        <!-- <td> __concat<br/>No </td> -->      
      </tr>
      <tr>
        <td> 11 </td>
        <td> &gt;=<br/>&gt;<br/>&lt;=<br/>&lt; </td>
        <td> Comparison Operators </td>
        <td> Left </td>
        <!-- <td> __ge<br/>__gt<br/>__le<br/>__lt </td> -->
      </tr>
      <tr>
        <td> 12 </td>
        <td> ==<br/>!=<br/>===<br/>!==</td>
        <td> Comparison Operators </td>
        <td> Left </td>
        <!-- <td> __eq<br/>__neq<br/>No<br/>No </td> -->
      </tr>
      <tr>
        <td> 13 </td>
        <td> && </td>
        <td> Logical And </td>
        <td> Left </td>
        <!-- <td> No </td> -->
      </tr>
      <tr>
        <td> 14 </td>
        <td> || </td>
        <td> Logical Or </td>
        <td> Left </td>
        <!-- <td> No </td> -->
      </tr>
      <tr>
        <td> 15 </td>
        <td> ?:<br/>?? </td>
        <td> Ternary Operator<br/>Undef Coalescing Operator </td>
        <td> Right </td>
        <!-- <td> No </td> -->
      </tr>
      <tr>
        <td> 16 </td>
        <td> =<br/>**=<br/>*=<br/>/=<br/>//=<br/>%=<br/>+=<br/>-=<br/>&gt;&gt;=<br/>&lt;&lt;=<br/>
             ~=<br/>||=<br/>&&=<br/>&amp;=<br/>^=<br/>|=<br/>??=
        </td>
        <td> Assignment </td>
        <td> Right </td>
        <!-- <td> No </td> -->
      </tr>
    </table>
    <h4> <a name="3.4.7">3.4.7 &ndash; Function Calls </a> </h4>
    <p> Functions can be called with the usual C-style syntax: e.g. <code>open("sample.txt", "a")</code> is a call to the 
      function <b>open</b>, with two parameters.
    </p>
    <h4> <a name="3.4.8">3.4.8 &ndash; Method Calls </a> </h4>
    <p> Methods can be called with the usual dot syntax: e.g. <code>f.close()</code> calls the methods <b>close</b> on 
      <b>f</b>.
    </p>
    <h2> <a name="4">4 &ndash; The Standard Library </a> </h2>
    <p> YASL provides the following builtin functions: </p>
    <table>
      <tr>
        <th> Function Name </th>
        <th> Arguments </th>
        <th> Purpose </th>
      </tr>
      <tr>
        <td> open(name, mode) </td>
        <td> name: name of file to open.<br/>
             mode: mode to open file in, e.g. "r" for readonly.
        </td>
        <td> opens the file given by <em>name</em> in mode given by <em>mode</em>. file opened this way should be closed with
          <code>.close</code>. </td>
      </tr>
      <tr>
        <td> popen(command, mode) </td>
        <td> command: command to run in shell.<br/>
             mode: end of process to connect to, either "r" or "w".
        </td>
        <td> runs the command given by <em>command</em> in the shell, and returns a stream to either read or write from the pipe
          , depending on <em>mode</em>. file opened this way should be closed with <code>.pclose</code> method. </td>
      </tr>
      <tr>
        <td> input(msg) </td>
        <td> msg: message to print to prompt user for input. </td>
        <td> prompts user for input using <em>msg</em>, then returns user input as string. </td>
      </tr>
    </table>
    <p> YASL provides the following methods for <em>float64</em>: </p>
    <table>
      <tr>
        <th> Method Name </th>
        <th> Arguments </th>
        <th> Purpose </th>
      </tr>
      <tr>
        <td> .toint64() </td>
        <td> </td>
        <td> Converts <em>float64</em> to an <em>int64</em>, truncating if necessary. </td>
      </tr>
      <tr>
        <td> .tostr() </td>
        <td> </td>
        <td> Converts <em>float64</em> to a <em>str</em>. </td>
      </tr>
    </table>
    <p> YASL provides the following methods for <em>int64</em>: </p>
    <table>
      <tr>
        <th> Method Name </th>
        <th> Arguments </th>
        <th> Purpose </th>
      </tr>
      <tr>
        <td> .tofloat64() </td>
        <td> </td>
        <td> Converts <em>int64</em> to an <em>float64</em>. </td>
      </tr>
      <tr>
        <td> .tostr() </td>
        <td> </td>
        <td> Converts <em>int64</em> to a <em>str</em>. </td>
      </tr>
    </table>
    <p> YASL provides the following methods for <em>bool</em>: </p>
    <table>
      <tr>
        <th> Method Name </th>
        <th> Arguments </th>
        <th> Purpose </th>
      </tr>
      <tr>
        <td> .tostr() </td>
        <td> </td>
        <td> Converts <em>bool</em> to a <em>str</em>. </td>
      </tr>
    </table>
    <p> YASL provides the following methods for <em>str</em>: </p>
    <table>
      <tr>
        <th> Method Name </th>
        <th> Arguments </th>
        <th> Purpose </th>
      </tr>
      <tr>
        <td> .tobool() </td>
        <td> </td>
        <td> Converts the given string to a bool: false if string is empty, true otherwise. </td>
      </tr>
      <tr>
        <td> .tostr() </td>
        <td> </td>
        <td> Does nothing. </td>
      </tr>
      <tr>
        <td> .upcase() </td>
        <td> </td>
        <td> Converts the given string to uppercase. </td>
      </tr>
      <tr>
        <td> .downcase() </td>
        <td> </td>
        <td> Converts the string to lowercase. </td>
      </tr>
      <tr>
        <td> .isalnum() </td>
        <td> </td>
        <td> Returns true if the given string is only letters and digits, false otherwise. </td>
      </tr>
      <tr>
        <td> .isal() </td>
        <td> </td>
        <td> Returns true if the given string is only letters, false otherwise. </td>
      </tr>
      <tr>
        <td> .isnum() </td>
        <td> </td>
        <td> Returns true if the given string is only digits, false otherwise. </td>
      </tr>
      <tr>
        <td> .isspace() </td>
        <td> </td>
        <td> Returns true if the given string is only whitespace characters, false otherwise. </td>
      </tr>
      <tr> 
        <td> .startswith(substr) </td>
        <td> substr: string to check against the start of given string. </td>
        <td> Returns true if the start of the given string is <em>substr</em>. </td>
      </tr>
      <tr> 
        <td> .endswith(substr) </td>
        <td> substr: string to check against the end of given string. </td>
        <td> Returns true if the end of the given string is <em>substr</em>. </td>
      </tr>
      <tr>
        <td> .search(substr) </td>
        <td> substr: string to try to find in given string. </td>
        <td> Returns index of first instance of <em>substr</em> in given string, <b>-1</b> if not found. </td>
      </tr>
      <tr>
        <td> .split(delim) </td>
        <td> delim: substring to split given string at. </td>
        <td> Splits given string at every occurance of <em>delim</em>, returning a list of all the substrings. </td>
      </tr>
    </table>
    <p> YASL provides the following methods for <em>list</em>: </p>
    <table>
      <tr>
        <th> Method Name </th>
        <th> Arguments </th>
        <th> Purpose </th>
      </tr>
      <tr>
        <td> .append(item) </td>
        <td> item: value to append to end of list. </td>
        <td> appends <em>value</em> to end of list. </td>
      </tr>
    </table>
    <p> YASL provides the following methods for <em>map</em>: </p>
    <table>
      <tr>
        <th> Method Name </th>
        <th> Arguments </th>
        <th> Purpose </th>
      </tr>
      <tr>
        <td> .keys() </td>
        <td> </td>
        <td> Returns a list of all keys found in map. </td>
      </tr>
      <tr>
        <td> .values() </td>
        <td> </td>
        <td> Returns a list of all values found in map. </td>
      </tr>
    </table>
    <p> YASL provides the following methods for <em>file</em>: </p>
    <table>
      <tr>
        <th> Method Name </th>
        <th> Arguments </th>
        <th> Purpose </th>
      </tr>
      <tr>
        <td> .close() </td>
        <td> </td>
        <td> Closes file opened with <em>open</em> </td>
      </tr>
      <tr>
        <td> .pclose() </td>
        <td> </td>
        <td> Closes file opened with <em>popen</em> </td>
      </tr>
      <tr>
        <td> .read() </td>
        <td> </td>
        <td> Reads entire content of file. </td>
      </tr>
      <tr>
        <td> .readline() </td>
        <td> </td>
        <td> Reads next line of file. </td>
      </tr>
      <tr>
        <td> .write(msg) </td>
        <td> msg: string to write to file. </td>
        <td> Writes <em>msg</em> to file. </td>
      </tr>
    </table>
  </div>
  
</body>
</html>
